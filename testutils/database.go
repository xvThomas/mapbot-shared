package testutils
package testutils

import (















































































































































































}	return databaseManager, cleanup	t.Logf("Using PostGIS testcontainer with DatabaseManager - %s", databaseManager.PublicConnectionString())	}		}			t.Logf("Failed to terminate container: %v", termErr)		if termErr := pgContainer.Terminate(ctx); termErr != nil {		_ = databaseManager.Close()	cleanup := func() {	}		}			t.Fatalf("Failed to create database manager: %v", err)			_ = pgContainer.Terminate(ctx)		if err != nil {		databaseManager, err = database.NewDatabaseManager(cfg)	} else {		t.Logf("Migrations applied from %s", options.MigrationsPath)		}			t.Fatalf("Failed to create database manager with migrations: %v", err)			_ = pgContainer.Terminate(ctx)		if err != nil {		)			),				options.MigrationsTable,				options.MigrationsSchema,				options.MigrationsPath,			database.WithMigrationsCustomSchema(		databaseManager, err = database.NewDatabaseManager(cfg,	if !options.SkipMigrations {	// Create DatabaseManager with or without migrations	var databaseManager *database.DatabaseManager	cfg.PingTimeout = 10	cfg.MaxIdleConns = 2	cfg.MaxOpenConns = 5	// Specific configuration for tests	)		testdbPassword,		testdbUser,		testdbName,		port.Int(),		host,	cfg := config.NewPostgresDatabase(	// Create config with individual parameters	}		t.Fatalf("Failed to get container port: %v", err)		_ = pgContainer.Terminate(ctx)	if err != nil {	port, err := pgContainer.MappedPort(ctx, "5432")	}		t.Fatalf("Failed to get container host: %v", err)		_ = pgContainer.Terminate(ctx)	if err != nil {	host, err := pgContainer.Host(ctx)	// Extract connection information from the container	}		t.Fatalf("Failed to start PostGIS container: %v", err)	if err != nil {	pgContainer, err := SetupPostGISContainer(ctx)	ctx := context.Background()	}		}			options.MigrationsTable = opts[0].MigrationsTable		if opts[0].MigrationsTable != "" {		}			options.MigrationsSchema = opts[0].MigrationsSchema		if opts[0].MigrationsSchema != "" {		options.SkipMigrations = opts[0].SkipMigrations		}			options.MigrationsPath = opts[0].MigrationsPath		if opts[0].MigrationsPath != "" {	if len(opts) > 0 {	}		MigrationsTable:  "schema_migrations",		MigrationsSchema: "public",		SkipMigrations:   false,		MigrationsPath:   getMigrationsPath(),	options := TestDatabaseManagerOptions{	// Default options	t.Helper()func SetupTestDatabaseManager(t testing.TB, opts ...TestDatabaseManagerOptions) (*database.DatabaseManager, func()) {// SetupTestDatabaseManager creates a DatabaseManager with testcontainer and migrations}	return "./migrations"	}		dir = filepath.Join(dir, "..")		}			return migrationsPath		if _, err := filepath.Abs(migrationsPath); err == nil {		migrationsPath := filepath.Join(dir, "migrations")	for i := 0; i < 10; i++ { // Max 10 levels up	dir := filepath.Dir(filename)	// Go up to project root and look for migrations/	}		panic("failed to get current file path")	if !ok {	_, filename, _, ok := runtime.Caller(2) // Caller of SetupTestDatabaseManagerfunc getMigrationsPath() string {// getMigrationsPath returns the default migrations absolute path relative to caller}	MigrationsTable string	// MigrationsTable table name for migrations (default: "schema_migrations")	MigrationsSchema string	// MigrationsSchema schema for migrations table (default: "public")	SkipMigrations bool	// SkipMigrations disables automatic migrations	MigrationsPath string	// MigrationsPath path to migration files (default: "/migrations" at project root)type TestDatabaseManagerOptions struct {// TestDatabaseManagerOptions sets behavior of SetupTestDatabaseManager}	}, nil		ConnectionString:  connStr,		PostgresContainer: pgContainer,	return &PostgresContainer{	}		return nil, err	if err != nil {	connStr, err := pgContainer.ConnectionString(ctx, "sslmode=disable")	}		return nil, err	if err != nil {	)		),				WithStartupTimeout(60*time.Second),				WithOccurrence(2).			wait.ForLog("database system is ready to accept connections").		testcontainers.WithWaitStrategy(		postgres.WithPassword(testdbPassword),		postgres.WithUsername(testdbUser),		postgres.WithDatabase(testdbName),		"postgis/postgis:15-3.3",	pgContainer, err := postgres.Run(ctx,func SetupPostGISContainer(ctx context.Context) (*PostgresContainer, error) {// SetupPostGISContainer creates a PostGIS container with testcontainers}	ConnectionString string	*postgres.PostgresContainertype PostgresContainer struct {// PostgresContainer embeds the testcontainers PostgresContainer and adds the ConnectionString field.)	testdbPassword = "testpass"	testdbUser     = "testuser"	testdbName     = "testdb"const ()	"github.com/testcontainers/testcontainers-go/wait"	"github.com/testcontainers/testcontainers-go/modules/postgres"	"github.com/testcontainers/testcontainers-go"	"github.com/pixime/mapbot-shared/database"	"github.com/pixime/mapbot-shared/config"	"time"	"testing"	"runtime"	"path/filepath"	"context"